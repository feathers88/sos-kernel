var searchIndex = {};
searchIndex["sos_kernel"] = {"doc":"# SOS kernel\nThis crate contains the kernel for SOS, the Stupid Operating System.","items":[[5,"kernel_main","sos_kernel","Kernel main loop",null,{"inputs":[],"output":null}],[5,"kernel_start","","Kernel initialization function called from ASM",null,{"inputs":[{"name":"paddr"}],"output":null}],[0,"memory","","Kernel memory management.",null,null],[3,"PAddr","sos_kernel::memory","A physical (linear) memory address is a 64-bit unsigned integer",null,null],[3,"VAddr","","A virtual address is a machine-sized unsigned integer",null,null],[3,"PageRange","","A range of `Page`s.",null,null],[3,"PageRangeIter","","An iterator over a range of pages",null,null],[5,"init_heap","","Initialise the kernel heap.",null,{"inputs":[],"output":{"name":"result"}}],[0,"alloc","","",null,null],[8,"Allocator","sos_kernel::memory::alloc","An `Allocator` implements a particular memory allocation strategy.",null,null],[10,"allocate","","Allocate a new block of size `size` on alignment `align`.",0,null],[10,"deallocate","","Release an allocated block of memory.",0,null],[11,"reallocate","","Reallocate `old_frame` from `old_size` bytes to `new_size` bytes",0,null],[11,"zero_alloc","","",0,null],[0,"paging","sos_kernel::memory","Non-arch-specific paging.",null,null],[3,"Page","sos_kernel::memory::paging","A virtual page",null,null],[12,"number","","",1,null],[3,"PageRange","","A range of pages",null,null],[3,"PageRangeIter","","An iterator over a range of pages",null,null],[8,"FrameAllocator","","Trait for a memory allocator which can allocate memory in terms of frames.",null,null],[10,"alloc_frame","","Allocate a new `Frame`",2,null],[10,"dealloc_frame","","Deallocate a given `Frame`.",2,null],[8,"Mapper","","",null,null],[16,"Flags","","",3,null],[16,"Frame","","",3,null],[10,"translate","","Translates a virtual address to the corresponding physical address.",3,null],[10,"translate_page","","Translates a virtual page to a physical frame.",3,null],[10,"map_to","","Modifies the page tables so that `page` maps to `frame`.",3,null],[10,"identity_map","","Identity map a given `frame`.",3,null],[10,"map_to_any","","Map the given `page` to any free frame.",3,null],[11,"clone","","",1,null],[11,"fmt","","",1,null],[11,"cmp","","",1,null],[11,"eq","","",1,null],[11,"ne","","",1,null],[11,"partial_cmp","","",1,null],[11,"lt","","",1,null],[11,"le","","",1,null],[11,"gt","","",1,null],[11,"ge","","",1,null],[11,"containing","","Create a new `Page` containing the given virtual address.",1,{"inputs":[{"name":"vaddr"}],"output":{"name":"page"}}],[11,"base_addr","","Return the start virtual address of this page",1,null],[11,"flush","","Flush the page from memory",1,null],[11,"pml4_index","","",1,null],[11,"pdpt_index","","",1,null],[11,"pd_index","","",1,null],[11,"pt_index","","",1,null],[11,"range_between","","Returns a `PageRange`",1,{"inputs":[{"name":"page"},{"name":"page"}],"output":{"name":"pagerange"}}],[11,"range_until","","Returns a `PageRange` on the pages from this page until the end page",1,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"ne","","",4,null],[11,"iter","","Returns an iterator over this `PageRange`",4,null],[11,"next","","",5,null],[0,"macros","sos_kernel::memory","Macros to make our custom address types require a lot less repetitive code.",null,null],[8,"Addr","","",null,null],[8,"Page","","Trait for a page. These can be virtual pages or physical frames.",null,null],[16,"Address","","The type of address used to address this `Page`.",6,null],[16,"R","","",6,null],[10,"containing","","Returns a new `Page` containing the given `Address`.",6,{"inputs":[{"name":"address"}],"output":{"name":"self"}}],[10,"base","","Returns the base `address` where this page starts.",6,null],[11,"range_between","","Returns a `PageRange` between two pages",6,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"pagerange"}}],[11,"range_until","","Returns a `FrameRange` on the frames from this frame until the end frame",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"cmp","","",7,null],[11,"eq","","",7,null],[11,"ne","","",7,null],[11,"partial_cmp","","",7,null],[11,"lt","","",7,null],[11,"le","","",7,null],[11,"gt","","",7,null],[11,"ge","","",7,null],[11,"into","","",7,null],[11,"from","","",7,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from","","",7,null],[11,"from","","",7,null],[11,"deref","","",7,null],[11,"as_mut_ptr","","",7,null],[11,"as_ptr","","",7,null],[11,"add","","",7,null],[11,"add","","",7,null],[11,"add","","",7,null],[11,"add","","",7,null],[11,"sub","","",7,null],[11,"sub","","",7,null],[11,"sub","","",7,null],[11,"sub","","",7,null],[11,"div","","",7,null],[11,"div","","",7,null],[11,"div","","",7,null],[11,"div","","",7,null],[11,"mul","","",7,null],[11,"mul","","",7,null],[11,"mul","","",7,null],[11,"mul","","",7,null],[11,"shl","","",7,null],[11,"shl","","",7,null],[11,"shl","","",7,null],[11,"shl","","",7,null],[11,"shr","","",7,null],[11,"shr","","",7,null],[11,"shr","","",7,null],[11,"shr","","",7,null],[11,"rem","","",7,null],[11,"rem","","",7,null],[11,"rem","","",7,null],[11,"rem","","",7,null],[11,"bitand","","",7,null],[11,"bitand","","",7,null],[11,"bitand","","",7,null],[11,"bitand","","",7,null],[11,"bitor","","",7,null],[11,"bitor","","",7,null],[11,"bitor","","",7,null],[11,"bitor","","",7,null],[11,"bitxor","","",7,null],[11,"bitxor","","",7,null],[11,"bitxor","","",7,null],[11,"bitxor","","",7,null],[11,"add_assign","","",7,null],[11,"add_assign","","",7,null],[11,"sub_assign","","",7,null],[11,"sub_assign","","",7,null],[11,"div_assign","","",7,null],[11,"div_assign","","",7,null],[11,"mul_assign","","",7,null],[11,"mul_assign","","",7,null],[11,"shl_assign","","",7,null],[11,"shl_assign","","",7,null],[11,"shr_assign","","",7,null],[11,"shr_assign","","",7,null],[11,"rem_assign","","",7,null],[11,"rem_assign","","",7,null],[11,"bitand_assign","","",7,null],[11,"bitand_assign","","",7,null],[11,"bitor_assign","","",7,null],[11,"bitor_assign","","",7,null],[11,"bitxor_assign","","",7,null],[11,"bitxor_assign","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"fmt","","",7,null],[11,"from_ptr","","",7,null],[11,"from_usize","","",7,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"as_usize","","",7,null],[11,"pml4_index","","Calculate the index in the PML4 table corresponding to this address.",7,null],[11,"pdpt_index","","Calculate the index in the PDPT table corresponding to this address.",7,null],[11,"pd_index","","Calculate the index in the PD table corresponding to this address.",7,null],[11,"pt_index","","Calculate the index in the PT table corresponding to this address.",7,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"iter","","Returns an iterator over this `PageRange`",8,null],[11,"next","","",9,null],[0,"io","sos_kernel","Kernel IO.",null,null],[0,"term","sos_kernel::io","",null,null],[7,"CONSOLE","sos_kernel::io::term","The system&#39;s global VGA terminal",null,null],[7,"__vga_buffer","","",null,null],[0,"keyboard","sos_kernel::io","PS/2 keyboard driver",null,null],[3,"Scancode","sos_kernel::io::keyboard","PS/2 keyboard scancode",null,null],[3,"Keyboard","","A PS/2 keyboard state",null,null],[12,"state","","The keyboard&#39;s modifier keys",10,null],[3,"Modifiers","","",null,null],[5,"read_char","","",null,{"inputs":[],"output":{"name":"option"}}],[17,"L_SHIFT","","",null,null],[17,"R_SHIFT","","",null,null],[17,"SHIFT","","",null,null],[17,"R_CTRL","","",null,null],[17,"L_CTRL","","",null,null],[17,"CTRL","","",null,null],[17,"R_ALT","","",null,null],[17,"L_ALT","","",null,null],[17,"ALT","","",null,null],[17,"CAPSLOCK","","",null,null],[17,"NUMLOCK","","",null,null],[11,"clone","","",11,null],[11,"fmt","","",11,null],[11,"read_scancode","","",10,null],[11,"eq","","",12,null],[11,"ne","","",12,null],[11,"clone","","",12,null],[11,"partial_cmp","","",12,null],[11,"lt","","",12,null],[11,"le","","",12,null],[11,"gt","","",12,null],[11,"ge","","",12,null],[11,"cmp","","",12,null],[11,"hash","","",12,null],[11,"fmt","","",12,null],[11,"empty","","Returns an empty set of flags.",12,{"inputs":[],"output":{"name":"modifiers"}}],[11,"all","","Returns the set containing all flags.",12,{"inputs":[],"output":{"name":"modifiers"}}],[11,"bits","","Returns the raw value of the flags currently stored.",12,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",12,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",12,{"inputs":[{"name":"u8"}],"output":{"name":"modifiers"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",12,null],[11,"is_all","","Returns `true` if all flags are currently set.",12,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",12,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",12,null],[11,"insert","","Inserts the specified flags in-place.",12,null],[11,"remove","","Removes the specified flags in-place.",12,null],[11,"toggle","","Toggles the specified flags in-place.",12,null],[11,"bitor","","Returns the union of the two sets of flags.",12,null],[11,"bitor_assign","","Adds the set of flags.",12,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",12,null],[11,"bitxor_assign","","Toggles the set of flags.",12,null],[11,"bitand","","Returns the intersection between the two sets of flags.",12,null],[11,"bitand_assign","","Disables all flags disabled in the set.",12,null],[11,"sub","","Returns the set difference of the two sets of flags.",12,null],[11,"sub_assign","","Disables all flags enabled in the set.",12,null],[11,"not","","Returns the complement of this set of flags.",12,null],[11,"extend","","",12,null],[11,"from_iter","","",12,{"inputs":[{"name":"t"}],"output":{"name":"modifiers"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"is_shifted","","Returns true if either shift key is pressed.",12,null],[11,"is_uppercase","","Returns true if the keyboard&#39;s state is currently uppercase.",12,null],[8,"Read","sos_kernel::io","The `Read` trait allows for reading bytes from a source.",null,null],[16,"Error","","",13,null],[10,"read","","Pull some bytes from this source into the specified buffer, returning\nhow many bytes were read.",13,null],[10,"read_all","","Read all bytes until EOF in this source, placing them into `buf`.",13,null],[8,"Write","","A trait for objects which are byte-oriented sinks.",null,null],[16,"Error","","",14,null],[10,"write","","Write a buffer into this object, returning how many bytes were written.",14,null],[0,"util","sos_kernel","General purpose stuff I couldn&#39;t find a better home for.",null,null],[4,"Void","sos_kernel::util","The unreachable Void type.",null,null],[11,"fmt","","",15,null],[0,"multiboot2","sos_kernel","Code for reading &amp; extracting data from Multiboot 2 boot information.",null,null],[3,"Info","sos_kernel::multiboot2","",null,null],[12,"length","","",16,null],[3,"Tag","","A Multiboot tag.",null,null],[12,"ty","","the type of this tag.",17,null],[3,"MemMapTag","","A Memory Map tag",null,null],[12,"entry_size","","",18,null],[12,"entry_version","","",18,null],[3,"CommandLineTag","","A tag that stores the boot command line.",null,null],[12,"command_line","","The boot command line.",19,null],[3,"ModulesTag","","",null,null],[12,"mod_begin","","The address at which the module begins.",20,null],[12,"mod_end","","The address at which the module ends.",20,null],[12,"string","","A string (typically a command line)",20,null],[3,"MemArea","","A multiboot 2 memory area",null,null],[12,"base","","the starting address of the memory area",21,null],[12,"length","","the length of the memory area",21,null],[12,"ty","","the type of the memory area",21,null],[3,"MemAreas","","An iterator over memory areas",null,null],[3,"ElfSectionsTag","","A Multiboot 2 ELF sections tag",null,null],[12,"n_sections","","the number of sections pointed to by this tag",22,null],[12,"section_size","","the size of each ELF section",22,null],[4,"TagType","","Types of Multiboot tags",null,null],[13,"End","","Tag that indicates the end of multiboot tags",23,null],[13,"CommandLine","","Command line passed to the bootloader",23,null],[13,"BootloaderName","","",23,null],[13,"Modules","","",23,null],[13,"BasicMemInfo","","",23,null],[13,"BIOSBootDev","","",23,null],[13,"MemoryMap","","",23,null],[13,"VBEInfo","","",23,null],[13,"FramebufferInfo","","",23,null],[13,"ELFSections","","",23,null],[13,"APMTable","","",23,null],[4,"MemAreaType","","",null,null],[13,"Available","","",24,null],[13,"Acpi","","",24,null],[13,"Preserve","","",24,null],[6,"Word","","",null,null],[11,"from","","",16,{"inputs":[{"name":"paddr"}],"output":{"name":"result"}}],[11,"get_tag","","Finds the tag with the given tag type.",16,null],[11,"mem_map","","Finds the memory map tag.",16,null],[11,"elf_sections","","Finds the ELF sections tag.",16,null],[11,"fmt","","",17,null],[11,"fmt","","",23,null],[11,"eq","","",23,null],[11,"areas","","Returns an iterator over all the memory areas in this tag.",18,null],[11,"fmt","","",24,null],[11,"eq","","",24,null],[11,"cmp","","",24,null],[11,"partial_cmp","","",24,null],[11,"address","","",21,null],[11,"clone","","",25,null],[11,"next","","",25,null],[11,"fmt","","",22,null],[11,"sections","","Returns an iterator over the ELF sections pointed to by this tag.",22,null],[0,"elf","sos_kernel","Parsing and loading Executable and Linkable Format (ELF) 32- and 64-bit\nbinaries.",null,null],[3,"Binary","sos_kernel::elf","A handle on an ELF binary",null,null],[12,"header","","",26,null],[0,"section","","",null,null],[3,"HeaderRepr","sos_kernel::elf::section","",null,null],[3,"Flags","","",null,null],[3,"GroupFlags","","",null,null],[3,"Sections","","Iterator over ELF64 sections",null,null],[4,"Header","","Represents an ELF section header",null,null],[13,"ThirtyTwo","","",27,null],[13,"SixtyFour","","",27,null],[4,"Contents","","",null,null],[13,"Empty","","",28,null],[13,"Undefined","","",28,null],[13,"Group","","",28,null],[12,"flags","sos_kernel::elf::section::Contents","",28,null],[12,"indicies","","",28,null],[4,"Type","sos_kernel::elf::section","Enum representing an ELF file section type.",null,null],[13,"Null","","Section type 0: `SHT_NULL`",29,null],[13,"ProgramBits","","Section type 1: `SHT_PROGBITS`",29,null],[13,"SymbolTable","","Section type 2: `SHT_SYMTAB`",29,null],[13,"StringTable","","Section type 3: `SHT_STRTAB`",29,null],[13,"Rela","","Section type 4: `SHT_RELA`",29,null],[13,"HashTable","","Section type 5: `SHT_HASH`",29,null],[13,"Dynamic","","Section type 6: `SHT_DYNAMIC`",29,null],[13,"Notes","","Section type 7: `SHT_NOTE`",29,null],[13,"NoBits","","Section type 8: `SHT_NOBITS`",29,null],[13,"Rel","","Section type 9: `SHT_REL`",29,null],[13,"Shlib","","Section type 10: `SHT_SHLIB`",29,null],[13,"DynSymTable","","Section type 11: `SHT_DYNSYM`",29,null],[13,"InitArray","","",29,null],[13,"FiniArray","","",29,null],[13,"PreInitArray","","",29,null],[13,"Group","","",29,null],[13,"SymbolTableShIndex","","",29,null],[13,"OsSpecific","","",29,null],[13,"ProcessorSpecific","","",29,null],[13,"User","","",29,null],[17,"SHN_UNDEF","","",null,null],[17,"SHN_LORESERVE","","",null,null],[17,"SHN_LOPROC","","",null,null],[17,"SHN_HIPROC","","",null,null],[17,"SHN_LOOS","","",null,null],[17,"SHN_HIOS","","",null,null],[17,"SHN_ABS","","",null,null],[17,"SHN_COMMON","","",null,null],[17,"SHN_XINDEX","","",null,null],[17,"SHN_HIRESERVE","","",null,null],[17,"SHT_LOOS","","",null,null],[17,"SHT_HIOS","","",null,null],[17,"SHT_LOPROC","","",null,null],[17,"SHT_HIPROC","","",null,null],[17,"SHT_LOUSER","","",null,null],[17,"SHT_HIUSER","","",null,null],[17,"SHF_WRITE","","",null,null],[17,"SHF_ALLOC","","",null,null],[17,"SHF_EXECINSTR","","",null,null],[17,"SHF_MERGE","","",null,null],[17,"SHF_STRINGS","","",null,null],[17,"SHF_INFO_LINK","","",null,null],[17,"SHF_LINK_ORDER","","",null,null],[17,"SHF_OS_NONCONFORMING","","",null,null],[17,"SHF_GROUP","","",null,null],[17,"SHF_TLS","","",null,null],[17,"SHF_COMPRESSED","","",null,null],[17,"SHF_MASKOS","","",null,null],[17,"SHF_MASKPROC","","",null,null],[17,"GRP_COMDAT","","",null,null],[17,"GRP_MASKOS","","",null,null],[17,"GRP_MASKPROC","","",null,null],[8,"AsHeader","","",null,null],[10,"as_header","","",30,null],[11,"clone","","",27,null],[11,"fmt","","",27,null],[11,"fmt","","",31,null],[11,"as_header","","",31,null],[11,"as_header","","",31,null],[11,"eq","","",32,null],[11,"ne","","",32,null],[11,"clone","","",32,null],[11,"partial_cmp","","",32,null],[11,"lt","","",32,null],[11,"le","","",32,null],[11,"gt","","",32,null],[11,"ge","","",32,null],[11,"cmp","","",32,null],[11,"hash","","",32,null],[11,"fmt","","",32,null],[11,"empty","","Returns an empty set of flags.",32,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",32,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",32,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",32,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",32,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",32,null],[11,"is_all","","Returns `true` if all flags are currently set.",32,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",32,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",32,null],[11,"insert","","Inserts the specified flags in-place.",32,null],[11,"remove","","Removes the specified flags in-place.",32,null],[11,"toggle","","Toggles the specified flags in-place.",32,null],[11,"bitor","","Returns the union of the two sets of flags.",32,null],[11,"bitor_assign","","Adds the set of flags.",32,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",32,null],[11,"bitxor_assign","","Toggles the set of flags.",32,null],[11,"bitand","","Returns the intersection between the two sets of flags.",32,null],[11,"bitand_assign","","Disables all flags disabled in the set.",32,null],[11,"sub","","Returns the set difference of the two sets of flags.",32,null],[11,"sub_assign","","Disables all flags enabled in the set.",32,null],[11,"not","","Returns the complement of this set of flags.",32,null],[11,"extend","","",32,null],[11,"from_iter","","",32,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",32,null],[11,"eq","","",33,null],[11,"ne","","",33,null],[11,"clone","","",33,null],[11,"partial_cmp","","",33,null],[11,"lt","","",33,null],[11,"le","","",33,null],[11,"gt","","",33,null],[11,"ge","","",33,null],[11,"cmp","","",33,null],[11,"hash","","",33,null],[11,"fmt","","",33,null],[11,"empty","","Returns an empty set of flags.",33,{"inputs":[],"output":{"name":"groupflags"}}],[11,"all","","Returns the set containing all flags.",33,{"inputs":[],"output":{"name":"groupflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",33,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",33,{"inputs":[{"name":"u32"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",33,{"inputs":[{"name":"u32"}],"output":{"name":"groupflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",33,null],[11,"is_all","","Returns `true` if all flags are currently set.",33,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",33,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",33,null],[11,"insert","","Inserts the specified flags in-place.",33,null],[11,"remove","","Removes the specified flags in-place.",33,null],[11,"toggle","","Toggles the specified flags in-place.",33,null],[11,"bitor","","Returns the union of the two sets of flags.",33,null],[11,"bitor_assign","","Adds the set of flags.",33,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",33,null],[11,"bitxor_assign","","Toggles the set of flags.",33,null],[11,"bitand","","Returns the intersection between the two sets of flags.",33,null],[11,"bitand_assign","","Disables all flags disabled in the set.",33,null],[11,"sub","","Returns the set difference of the two sets of flags.",33,null],[11,"sub_assign","","Disables all flags enabled in the set.",33,null],[11,"not","","Returns the complement of this set of flags.",33,null],[11,"extend","","",33,null],[11,"from_iter","","",33,{"inputs":[{"name":"t"}],"output":{"name":"groupflags"}}],[11,"offset","","",27,null],[11,"length","","",27,null],[11,"link","","",27,null],[11,"info","","",27,null],[11,"address_align","","",27,null],[11,"entry_length","","",27,null],[11,"addr","","Returns the start address of this section",27,null],[11,"end_addr","","Returns the end address of this section",27,null],[11,"flags","","Returns the type of this section",27,null],[11,"get_type","","Returns the type of this section",27,null],[11,"is_writable","","Returns true if this section is writable.",27,null],[11,"is_allocated","","Returns true if this section occupies memory during program execution.",27,null],[11,"is_executable","","Returns true if this section contains executable instructions.",27,null],[11,"is_mergeable","","Returns true if this section can be merged.",27,null],[11,"is_uniform","","Returns true if this section contains data that is of a uniform size.",27,null],[11,"fmt","","",29,null],[11,"eq","","",29,null],[11,"ne","","",29,null],[11,"cmp","","",29,null],[11,"partial_cmp","","",29,null],[11,"lt","","",29,null],[11,"le","","",29,null],[11,"gt","","",29,null],[11,"ge","","",29,null],[11,"clone","","",34,null],[11,"fmt","","",34,null],[11,"new","","",34,{"inputs":[{"name":"headerrepr"},{"name":"u32"},{"name":"u32"}],"output":{"name":"sections"}}],[11,"next","","",34,null],[0,"file","sos_kernel::elf","",null,null],[3,"Header","sos_kernel::elf::file","An ELF file header",null,null],[12,"ident","","",35,null],[12,"machine","","",35,null],[12,"entry_point","","Program entry point",35,null],[12,"ph_offset","","Offset for start of program headers",35,null],[12,"sh_offset","","Offset for start of section headers",35,null],[12,"flags","","",35,null],[12,"header_size","","",35,null],[12,"ph_entry_size","","",35,null],[12,"ph_count","","",35,null],[12,"sh_entry_size","","",35,null],[12,"sh_count","","",35,null],[12,"sh_str_idx","","",35,null],[3,"Ident","","ELF identifier (`e_ident` in the ELF standard)",null,null],[12,"magic","","ELF magic numbers. Must be [0x7, E, L, F]",36,null],[12,"class","","ELF file class (32- or 64-bit)",36,null],[12,"data","","ELF data encoding (big- or little-endian)",36,null],[12,"version","","ELF file version",36,null],[12,"abi","","",36,null],[12,"abi_version","","ABI version (often this is just padding)",36,null],[4,"Class","","Identifies the class of the ELF file",null,null],[13,"None","","Invalid ELF class file (`ELFCLASSNONE` in the standard)",37,null],[13,"Elf32","","32-bit ELF file (`ELFCLASS32` in the standard)",37,null],[13,"Elf64","","64-bit ELF file (`ELFCLASS64` in the standard)",37,null],[4,"DataEncoding","","Identifies the data encoding of the ELF file",null,null],[13,"None","","Invalid data encoding (`ELFDATANONE` in the standard)",38,null],[13,"LittleEndian","","Twos-complement little-endian data encoding\n(`ELFDATA2LSB` in the standard)",38,null],[13,"BigEndian","","Twos-complement big-endian data encoding\n(`ELFDATA2MSB` in the standard)",38,null],[4,"OsAbi","","Operating system ABI",null,null],[13,"SystemV","","Ox00 also represents &quot;none&quot;",39,null],[13,"HpUx","","",39,null],[13,"NetBsd","","",39,null],[13,"Linux","","",39,null],[13,"Solaris","","",39,null],[13,"Aix","","",39,null],[13,"Irix","","",39,null],[13,"FreeBsd","","",39,null],[13,"OpenBsd","","",39,null],[13,"OpenVms","","",39,null],[4,"Version","","Identifies the version of the ELF file",null,null],[13,"None","","",40,null],[13,"Current","","",40,null],[4,"Type","","",null,null],[13,"None","","",41,null],[13,"Relocatable","","",41,null],[13,"Executable","","",41,null],[13,"SharedObject","","",41,null],[13,"Core","","",41,null],[13,"Other","","",41,null],[4,"Machine","","",null,null],[13,"None","","",42,null],[13,"Sparc","","",42,null],[13,"X86","","",42,null],[13,"Mips","","",42,null],[13,"PowerPc","","",42,null],[13,"Arm","","",42,null],[13,"SuperH","","",42,null],[13,"Ia64","","",42,null],[13,"X86_64","","",42,null],[13,"AArch64","","",42,null],[6,"Magic","","Type of header magic",null,null],[17,"MAGIC","","ELF header magic",null,null],[11,"clone","","",35,null],[11,"fmt","","",35,null],[11,"from_slice","","Attempt to extract an ELF file header from a slice of bytes.",35,null],[11,"get_type","","",35,null],[11,"parse_section","","Attempt to extract a section header from a slice of bytes.",35,null],[11,"parse_section","","Attempt to extract a section header from a slice of bytes.",35,null],[11,"clone","","",36,null],[11,"fmt","","",36,null],[11,"check_magic","","",36,null],[11,"clone","","",37,null],[11,"eq","","",37,null],[11,"fmt","","",37,null],[11,"clone","","",38,null],[11,"eq","","",38,null],[11,"fmt","","",38,null],[11,"clone","","",39,null],[11,"fmt","","",39,null],[11,"clone","","",40,null],[11,"eq","","",40,null],[11,"fmt","","",40,null],[11,"clone","","",41,null],[11,"eq","","",41,null],[11,"ne","","",41,null],[11,"fmt","","",41,null],[11,"clone","","",42,null],[11,"eq","","",42,null],[11,"fmt","","",42,null],[6,"Section","sos_kernel::elf","An ELF section header.",null,null],[6,"FileHeader","","An ELF header file.",null,null],[6,"ElfResult","","",null,null],[8,"ElfWord","","",null,null],[11,"fmt","","",26,null],[0,"arch","sos_kernel","Architecture-specific implementation.",null,null],[5,"arch_init","sos_kernel::arch","Entry point for architecture-specific kernel init",null,{"inputs":[{"name":"paddr"}],"output":null}],[11,"clone","sos_kernel::memory","",43,null],[11,"fmt","","",43,null],[11,"cmp","","",43,null],[11,"eq","","",43,null],[11,"ne","","",43,null],[11,"partial_cmp","","",43,null],[11,"lt","","",43,null],[11,"le","","",43,null],[11,"gt","","",43,null],[11,"ge","","",43,null],[11,"into","","",43,null],[11,"from","","",43,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"from","","",43,null],[11,"from","","",43,null],[11,"deref","","",43,null],[11,"as_mut_ptr","","",43,null],[11,"as_ptr","","",43,null],[11,"add","","",43,null],[11,"add","","",43,null],[11,"add","","",43,null],[11,"add","","",43,null],[11,"sub","","",43,null],[11,"sub","","",43,null],[11,"sub","","",43,null],[11,"sub","","",43,null],[11,"div","","",43,null],[11,"div","","",43,null],[11,"div","","",43,null],[11,"div","","",43,null],[11,"mul","","",43,null],[11,"mul","","",43,null],[11,"mul","","",43,null],[11,"mul","","",43,null],[11,"shl","","",43,null],[11,"shl","","",43,null],[11,"shl","","",43,null],[11,"shl","","",43,null],[11,"shr","","",43,null],[11,"shr","","",43,null],[11,"shr","","",43,null],[11,"shr","","",43,null],[11,"rem","","",43,null],[11,"rem","","",43,null],[11,"rem","","",43,null],[11,"rem","","",43,null],[11,"bitand","","",43,null],[11,"bitand","","",43,null],[11,"bitand","","",43,null],[11,"bitand","","",43,null],[11,"bitor","","",43,null],[11,"bitor","","",43,null],[11,"bitor","","",43,null],[11,"bitor","","",43,null],[11,"bitxor","","",43,null],[11,"bitxor","","",43,null],[11,"bitxor","","",43,null],[11,"bitxor","","",43,null],[11,"add_assign","","",43,null],[11,"add_assign","","",43,null],[11,"sub_assign","","",43,null],[11,"sub_assign","","",43,null],[11,"div_assign","","",43,null],[11,"div_assign","","",43,null],[11,"mul_assign","","",43,null],[11,"mul_assign","","",43,null],[11,"shl_assign","","",43,null],[11,"shl_assign","","",43,null],[11,"shr_assign","","",43,null],[11,"shr_assign","","",43,null],[11,"rem_assign","","",43,null],[11,"rem_assign","","",43,null],[11,"bitand_assign","","",43,null],[11,"bitand_assign","","",43,null],[11,"bitor_assign","","",43,null],[11,"bitor_assign","","",43,null],[11,"bitxor_assign","","",43,null],[11,"bitxor_assign","","",43,null],[11,"fmt","","",43,null],[11,"fmt","","",43,null],[11,"fmt","","",43,null],[11,"fmt","","",43,null],[11,"fmt","","",43,null],[0,"cpu","sos_kernel::arch","Code for interacting with the `x86_64` CPU.",null,null],[3,"Registers","sos_kernel::arch::cpu","Registers pushed to the stack when handling an interrupt or context switch.",null,null],[12,"rsi","","",44,null],[12,"rdi","","",44,null],[12,"r11","","",44,null],[12,"r10","","",44,null],[12,"r9","","",44,null],[12,"r8","","",44,null],[12,"rdx","","",44,null],[12,"rcx","","",44,null],[12,"rax","","",44,null],[3,"Port","","",null,null],[4,"PrivilegeLevel","","Represents an x86 privilege level.",null,null],[13,"KernelMode","","Ring 0 is the most privileged ring",45,null],[13,"Ring1","","",45,null],[13,"Ring2","","",45,null],[13,"UserMode","","Ring 3 is the least privileged ring",45,null],[0,"interrupts","","64-bit Interrupt Descriptor Table implementation.",null,null],[3,"InterruptContext","sos_kernel::arch::cpu::interrupts","State stored when handling an interrupt.",null,null],[12,"registers","","callee-saved registers",46,null],[12,"int_id","","interrupt ID number",46,null],[3,"ExceptionInfo","","",null,null],[12,"name","","",47,null],[12,"mnemonic","","",47,null],[12,"irq_type","","",47,null],[12,"source","","",47,null],[5,"handle_interrupt","","Kernel interrupt-handling function.",null,{"inputs":[{"name":"interruptcontext"}],"output":null}],[5,"handle_cpu_exception","","Handle a CPU exception with a given interrupt context.",null,null],[5,"initialize","","Initialize interrupt handling.",null,{"inputs":[],"output":null}],[0,"idt","","Common functionality for the `x86` and `x86_64` Interrupt Descriptor Table.",null,null],[3,"Gate","sos_kernel::arch::cpu::interrupts::idt","An IDT entry is called a gate.",null,null],[12,"offset_lower","","bits 0 - 15 of the offset",48,null],[12,"selector","","code segment selector (GDT or LDT)",48,null],[12,"flags","","indicates the gate&#39;s type and attributes.\nthe second half indicates the type:\n  + `0b1100`: Call gate\n  + `0b1110`: Interrupt gate\n  + `0b1111`: Trap Gate",48,null],[12,"offset_mid","","bits 16 - 31 of the offset",48,null],[12,"offset_upper","","bits 32 - 63 of the offset",48,null],[3,"GateFlags","","",null,null],[3,"Idt","","An Interrupt Descriptor Table",null,null],[0,"gate","","64-bit IDT gate implementation",null,null],[3,"Gate","sos_kernel::arch::cpu::interrupts::idt::gate","An IDT entry is called a gate.",null,null],[12,"offset_lower","","bits 0 - 15 of the offset",48,null],[12,"selector","","code segment selector (GDT or LDT)",48,null],[12,"flags","","indicates the gate&#39;s type and attributes.\nthe second half indicates the type:\n  + `0b1100`: Call gate\n  + `0b1110`: Interrupt gate\n  + `0b1111`: Trap Gate",48,null],[12,"offset_mid","","bits 16 - 31 of the offset",48,null],[12,"offset_upper","","bits 32 - 63 of the offset",48,null],[6,"Handler","sos_kernel::arch::cpu::interrupts::idt","An interrupt handler function.",null,null],[17,"ENTRIES","","Number of entries in the system&#39;s Interrupt Descriptor Table.",null,null],[17,"PRESENT","","Indicates whether or not this gate is present.\nAn interrupt on a non-present gate will trigger a\nGeneral Protection Fault.",null,null],[17,"DPL_RING_0","","",null,null],[17,"DPL_RING_1","","",null,null],[17,"DPL_RING_2","","",null,null],[17,"DPL_RING_3","","",null,null],[17,"DPL","","",null,null],[17,"SEGMENT","","",null,null],[17,"LONG_MODE","","",null,null],[17,"INT_GATE_16","","",null,null],[17,"INT_GATE_32","","",null,null],[17,"TRAP_GATE_16","","",null,null],[17,"TRAP_GATE_32","","",null,null],[17,"TASK_GATE_32","","",null,null],[0,"pics","sos_kernel::arch::cpu::interrupts","Support for the 8259 Programmable Interrupt Controller.",null,null],[3,"PIC","sos_kernel::arch::cpu::interrupts::pics","A 8259 Programmable Interrupt Controller.",null,null],[4,"IRQ","","List of IRQs on the x86.",null,null],[13,"Timer","","System timer IRQ",49,null],[13,"PS2Keyboard","","PS/2 keyboard controller",49,null],[13,"Cascade","","PIC2 cascade IRQ",49,null],[13,"COM2","","COM2 serial port",49,null],[13,"COM1","","COM1 serial port",49,null],[13,"LPT2","","Line printer 2",49,null],[13,"Floppy","","Floppy disc controller",49,null],[13,"LPT1","","Line printer 1",49,null],[13,"RTCTimer","","CMOS clock",49,null],[13,"PS2Mouse","","PS/2 mouse controller",49,null],[13,"FPU","","Floating-point Coprocessor",49,null],[13,"PrimaryATA","","ATA channel 1",49,null],[13,"SecondaryATA","","ATA channel 2",49,null],[5,"initialize","","Initialize the system&#39;s Programmable Interrupt Controller",null,{"inputs":[],"output":null}],[5,"end_pic_interrupt","","If an interrupt is being handled by the PICs, end that interrupt.",null,{"inputs":[{"name":"u8"}],"output":null}],[7,"EXCEPTIONS","sos_kernel::arch::cpu::interrupts","x86 exceptions.",null,null],[0,"context","sos_kernel::arch::cpu","`x86_64` execution contexts.",null,null],[3,"Registers","sos_kernel::arch::cpu::context","Registers pushed to the stack when handling an interrupt or context switch.",null,null],[12,"rsi","","",44,null],[12,"rdi","","",44,null],[12,"r11","","",44,null],[12,"r10","","",44,null],[12,"r9","","",44,null],[12,"r8","","",44,null],[12,"rdx","","",44,null],[12,"rcx","","",44,null],[12,"rax","","",44,null],[3,"Context","","Thread execution context",null,null],[12,"rsp","","Value of the stack pointer (`rsp`) register",50,null],[12,"registers","","Value of the caller-saved registers",50,null],[12,"rip","","Value of the instruction pointer (`rip`) register",50,null],[0,"task","sos_kernel::arch::cpu","Tasking",null,null],[3,"StateDescriptor","sos_kernel::arch::cpu::task","A 64-bit Task State Descriptor",null,null],[12,"upper","","",51,null],[12,"lower","","",51,null],[3,"StateSegment","","A 64-bit Task State Segment",null,null],[12,"rsp","","64-bit values of the stack pointers (`%rsp`) for privilege rings 0-2",52,null],[12,"ist","","64-bit values of the interrupt stack table registers",52,null],[12,"iomap_base_offset","","the base offset of the IO map",52,null],[0,"gdt","sos_kernel::arch::cpu","The Global Descriptor Table (GDT) is used for configuring segmentation.",null,null],[0,"control_regs","","`x86` and `x86_64` control registers",null,null],[3,"CrState","sos_kernel::arch::cpu::control_regs","A struct bundling together a snapshot of the control registers state.",null,null],[12,"cr0","","`$cr0` contains flags that control the CPU&#39;s operations",53,null],[12,"cr2","","`$cr2` contains the page fault linear address",53,null],[12,"cr3","","`$cr3` contains the page table root pointer",53,null],[12,"cr4","","`$cr4` contains flags that control operations in\nprotected mode",53,null],[5,"dump","","Dump the current contents of the control registers to a `CrState`.",null,{"inputs":[],"output":{"name":"crstate"}}],[0,"cr0","","`%cr0` contains flags that modify basic processor operation.",null,null],[3,"Flags","sos_kernel::arch::cpu::control_regs::cr0","",null,null],[5,"is_paging_enabled","","If set, enable paging; if unset, disable paging.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"enable_paging","","If set, enable paging; if unset, disable paging.",null,{"inputs":[{"name":"bool"}],"output":null}],[5,"is_write_protected","","If set, enable the write protect bit; if unset, disable write protect.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"enable_write_protect","","If set, enable the write protect bit; if unset, disable write protect.",null,{"inputs":[{"name":"bool"}],"output":null}],[5,"read","","Read the current value from `%cr0`.",null,{"inputs":[],"output":{"name":"flags"}}],[5,"write","","Write a value to `%cr0`.",null,{"inputs":[{"name":"flags"}],"output":null}],[17,"PE","","Protected Mode Enable",null,null],[17,"MP","","Monitor co-processor",null,null],[17,"EM","","FPU Emulation",null,null],[17,"TS","","Task Switched",null,null],[17,"ET","","Extension Type",null,null],[17,"NE","","Numeric Error",null,null],[17,"WP","","Write Protect",null,null],[17,"AM","","Alignment Mask",null,null],[17,"NW","","Not Write-Through",null,null],[17,"CD","","Cache Disable",null,null],[17,"PG","","Paging",null,null],[0,"cr4","sos_kernel::arch::cpu::control_regs","`%cr4` contains flags that control protected mode execution.",null,null],[3,"Flags","sos_kernel::arch::cpu::control_regs::cr4","Bitflags present in `$cr4`",null,null],[5,"read","","Read the current value from `$cr4`.",null,{"inputs":[],"output":{"name":"flags"}}],[5,"write","","Write a value to `$cr4`.",null,{"inputs":[{"name":"flags"}],"output":null}],[5,"is_timestamp_disabled","","If disabled, the `RTDSC` instruction can only be executed in Ring 0.",null,{"inputs":[],"output":{"name":"bool"}}],[5,"disable_timestamp","","If disabled, the `RTDSC` instruction can only be executed in Ring 0.",null,{"inputs":[{"name":"bool"}],"output":null}],[17,"VME","","Virtual 8086 Mode Extensions",null,null],[17,"PVI","","Protected-mode Virtual Interrupts",null,null],[17,"TSD","","Time Stamp Disable",null,null],[17,"DE","","Debugging Extensions",null,null],[17,"PSE","","Page Size Extension",null,null],[17,"PAE","","Physical Address Extension",null,null],[17,"MCE","","Machine Check Exception",null,null],[17,"PGE","","Page Global Enabled",null,null],[17,"PCE","","Performance-Monitoring Counter enable",null,null],[17,"OSFXSR","","Operating system support for `FXSAVE` and `FXRSTOR` instructions",null,null],[17,"OSXMMEXCPT","","Operating System Support for Unmasked SIMD Floating-Point Exceptions",null,null],[17,"VMXE","","Virtual Machine Extensions Enable",null,null],[17,"SMXE","","Safer Mode Extensions Enable",null,null],[17,"FSGSBASE","","Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.",null,null],[17,"PCIDE","","PCID Enable",null,null],[17,"OSXSAVE","","`XSAVE` and Processor Extended States Enable",null,null],[17,"SMEP","","Supervisor Mode Execution Protection Enable",null,null],[17,"SMAP","","Supervisor Mode Access Protection Enable",null,null],[17,"PKE","","Protection Key Enable",null,null],[0,"cr2","sos_kernel::arch::cpu::control_regs","",null,null],[5,"read","sos_kernel::arch::cpu::control_regs::cr2","Read the current value from `$cr2`.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"write","","Write a value to `$cr2`.",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"cr3","sos_kernel::arch::cpu::control_regs","",null,null],[5,"read","sos_kernel::arch::cpu::control_regs::cr3","Read the current value from `$cr3`.",null,{"inputs":[],"output":{"name":"usize"}}],[5,"write","","Write a value to `$cr3`.",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"segment","sos_kernel::arch::cpu","Code for using the `x86` and `x86_64` segmentation hardware.",null,null],[3,"Selector","sos_kernel::arch::cpu::segment","A segment selector is a 16-bit identifier for a segment.",null,null],[3,"Descriptor","","A segment descriptor is an entry in an IDT or GDT.",null,null],[12,"base_high","","The last 8 bits of the base address",54,null],[12,"flags","","The next 16 bits are bitflags",54,null],[12,"base_mid","","The middle 8 bits of the base address",54,null],[12,"base_low","","The first 16 bits of the base address",54,null],[12,"limit","","the segment limit",54,null],[3,"Flags","","",null,null],[3,"DataFlags","","",null,null],[3,"CodeFlags","","",null,null],[4,"Type","","",null,null],[13,"System","","",55,null],[13,"Code","","",55,null],[13,"Data","","",55,null],[4,"SysType","","",null,null],[13,"Ldt","","",56,null],[13,"TssAvailable","","",56,null],[13,"TssBusy","","",56,null],[13,"CallGate","","",56,null],[13,"InterruptGate","","",56,null],[13,"TrapGate","","",56,null],[17,"RPL_RING_0","","",null,null],[17,"RPL_RING_1","","",null,null],[17,"RPL_RING_2","","",null,null],[17,"RPL_RING_3","","",null,null],[17,"RPL","","Requested Prrivelege Level (RPL)",null,null],[17,"TI_GDT","","If the Table Indicator (TI) is 0, use the GDT",null,null],[17,"TI_LDT","","If the TI is 1, use the LDT",null,null],[17,"CODE_DATA_ACC","","1 if this is a code or data segment that has been accessed",null,null],[17,"SEGMENT_TYPE","","",null,null],[17,"DESCR_TYPE","","",null,null],[17,"DPL","","",null,null],[17,"PRESENT","","",null,null],[17,"LIMIT","","",null,null],[17,"AVAILABLE","","",null,null],[17,"LENGTH","","",null,null],[17,"DEFAULT_SIZE","","",null,null],[17,"GRANULARITY","","",null,null],[17,"ACCESSED","","If this is a code or data segment and the accessed bit is set,\nit has been accessed.",null,null],[17,"DATA_ACCESSED","","",null,null],[17,"WRITE","","",null,null],[17,"EXPAND_DOWN","","",null,null],[17,"CODE_ACCESSED","","",null,null],[17,"READ","","",null,null],[17,"EXECUTE","","",null,null],[17,"CONFORMING","","",null,null],[17,"EXEC_ONLY","","",null,null],[0,"dtable","sos_kernel::arch::cpu","`x86` and `x86_64` descriptor tables (IDT, GDT, or LDT)",null,null],[3,"Pointer","sos_kernel::arch::cpu::dtable","A pointer to a descriptor table.\nThis is a format suitable",null,null],[12,"limit","","the length of the descriptor table",57,null],[12,"base","","pointer to the region in memory\ncontaining the descriptor table.",57,null],[8,"DTable","","A descriptor table (IDT or GDT)",null,null],[16,"Entry","","",58,null],[11,"get_ptr","","Get the IDT pointer struct to pass to `lidt` or `lgdt`",58,null],[10,"entry_count","","Returns the number of Entries in the `DTable`.",58,null],[10,"load","","Load the descriptor table with the appropriate load instruction",58,null],[0,"flags","sos_kernel::arch::cpu","Flags present in the `%eflags`/`%rflags` register on x86 CPUs.",null,null],[3,"Flags","sos_kernel::arch::cpu::flags","Contents of the `%eflags`/`%rflags` register.",null,null],[5,"read","","Read the current value from `$eflags`/`%rflags`.",null,{"inputs":[],"output":{"name":"flags"}}],[17,"CF","","Carry flag",null,null],[17,"PF","","Parity flag",null,null],[17,"AF","","Adjust flag",null,null],[17,"ZF","","Zero flag",null,null],[17,"SF","","Sign flag",null,null],[17,"TF","","Trap flag (single step)",null,null],[17,"IF","","Interrupt enable flag",null,null],[17,"DF","","Direction flag",null,null],[17,"OF","","Overflow flag",null,null],[17,"IOPL_RING_0","","",null,null],[17,"IOPL_RING_1","","",null,null],[17,"IOPL_RING_2","","",null,null],[17,"IOPL_RING_3","","",null,null],[17,"IOPL","","I/0 Privilege Level",null,null],[17,"NT","","Nested task flag",null,null],[17,"RESERVED","","Should always be 1",null,null],[17,"RF","","Resume flag",null,null],[17,"VM","","Virtual 8086 Mode flag",null,null],[17,"AC","","Alignment Check",null,null],[17,"VIF","","Virtual Interrupt flag",null,null],[17,"VIP","","Virtual Interrupt Pending",null,null],[17,"ID","","Able to use `CPUID` instruction.",null,null],[0,"timer","sos_kernel::arch::cpu","",null,null],[0,"timestamp","sos_kernel::arch::cpu::timer","",null,null],[5,"rtdsc","sos_kernel::arch::cpu::timer::timestamp","Read the current value of the timestamp counter.",null,{"inputs":[],"output":{"name":"u64"}}],[5,"rtdscp","","Read the current timestamp, after other instructions have been executed.",null,{"inputs":[],"output":{"name":"u64"}}],[5,"is_available","","Returns true if timestamps are currently available.",null,{"inputs":[],"output":{"name":"result"}}],[5,"get_timestamp","","Returns the current timestamp, or an error",null,{"inputs":[],"output":{"name":"result"}}],[5,"wait_get_timestamp","","Returns the current timestamp or an error, after other instructions have\nbeen executed.",null,{"inputs":[],"output":{"name":"result"}}],[0,"memory","sos_kernel::arch","Architecture-specific memory management.",null,null],[3,"PAddr","sos_kernel::arch::memory","A physical (linear) memory address is a 64-bit unsigned integer",null,null],[3,"Frame","","A frame (physical page)",null,null],[12,"number","","",59,null],[3,"FrameRange","","A range of frames",null,null],[3,"FrameRangeIter","","An iterator over a range of frames",null,null],[7,"HEAP_BASE","","",null,null],[7,"HEAP_TOP","","",null,null],[7,"STACK_BASE","","",null,null],[7,"STACK_TOP","","",null,null],[0,"paging","","`x86_64` paging.",null,null],[3,"ActivePML4","sos_kernel::arch::memory::paging","Struct representing the currently active PML4 instance.",null,null],[0,"table","","Page tables.",null,null],[3,"Table","sos_kernel::arch::memory::paging::table","A page table",null,null],[12,"entries","","The entries in the page table.",60,null],[3,"Entry","","A page table entry.",null,null],[3,"EntryFlags","","",null,null],[4,"PML4Level","","",null,null],[4,"PDPTLevel","","",null,null],[4,"PDLevel","","",null,null],[4,"PTLevel","","",null,null],[17,"N_ENTRIES","","The number of entries in a page table.",null,null],[17,"PAGE_TABLE_SIZE","","Size of a page table (in bytes)",null,null],[17,"PML4","","PML4 table",null,null],[17,"PRESENT","","Present flag.\nMust be 1 to map a 2-MByte page or reference a page table.",null,null],[17,"WRITABLE","","Writable flag.\nIf 0, writes may not be allowed to the 2-MB region controlled\nby this entry",null,null],[17,"USER_ACCESSIBLE","","",null,null],[17,"WRITE_THROUGH","","",null,null],[17,"NO_CACHE","","",null,null],[17,"ACCESSED","","",null,null],[17,"DIRTY","","",null,null],[17,"HUGE_PAGE","","",null,null],[17,"GLOBAL","","",null,null],[17,"NO_EXECUTE","","",null,null],[8,"TableLevel","","",null,null],[8,"Sublevel","","",null,null],[16,"Next","","",61,null],[17,"PAGE_SHIFT","sos_kernel::arch::memory","",null,null],[17,"PAGE_SIZE","","The size of a page (4mb)",null,null],[17,"ARCH_BITS","sos_kernel::arch","",null,null],[0,"panic","sos_kernel","Panic handling.",null,null],[5,"rust_begin_unwind","sos_kernel::panic","Called to handle a panic.",null,null],[11,"eq","sos_kernel::arch::cpu::control_regs::cr0","",62,null],[11,"ne","","",62,null],[11,"clone","","",62,null],[11,"partial_cmp","","",62,null],[11,"lt","","",62,null],[11,"le","","",62,null],[11,"gt","","",62,null],[11,"ge","","",62,null],[11,"cmp","","",62,null],[11,"hash","","",62,null],[11,"fmt","","",62,null],[11,"empty","","Returns an empty set of flags.",62,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",62,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",62,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",62,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",62,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",62,null],[11,"is_all","","Returns `true` if all flags are currently set.",62,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",62,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",62,null],[11,"insert","","Inserts the specified flags in-place.",62,null],[11,"remove","","Removes the specified flags in-place.",62,null],[11,"toggle","","Toggles the specified flags in-place.",62,null],[11,"bitor","","Returns the union of the two sets of flags.",62,null],[11,"bitor_assign","","Adds the set of flags.",62,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",62,null],[11,"bitxor_assign","","Toggles the set of flags.",62,null],[11,"bitand","","Returns the intersection between the two sets of flags.",62,null],[11,"bitand_assign","","Disables all flags disabled in the set.",62,null],[11,"sub","","Returns the set difference of the two sets of flags.",62,null],[11,"sub_assign","","Disables all flags enabled in the set.",62,null],[11,"not","","Returns the complement of this set of flags.",62,null],[11,"extend","","",62,null],[11,"from_iter","","",62,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",62,null],[11,"eq","sos_kernel::arch::cpu::control_regs::cr4","",63,null],[11,"ne","","",63,null],[11,"clone","","",63,null],[11,"partial_cmp","","",63,null],[11,"lt","","",63,null],[11,"le","","",63,null],[11,"gt","","",63,null],[11,"ge","","",63,null],[11,"cmp","","",63,null],[11,"hash","","",63,null],[11,"fmt","","",63,null],[11,"empty","","Returns an empty set of flags.",63,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",63,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",63,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",63,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",63,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",63,null],[11,"is_all","","Returns `true` if all flags are currently set.",63,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",63,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",63,null],[11,"insert","","Inserts the specified flags in-place.",63,null],[11,"remove","","Removes the specified flags in-place.",63,null],[11,"toggle","","Toggles the specified flags in-place.",63,null],[11,"bitor","","Returns the union of the two sets of flags.",63,null],[11,"bitor_assign","","Adds the set of flags.",63,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",63,null],[11,"bitxor_assign","","Toggles the set of flags.",63,null],[11,"bitand","","Returns the intersection between the two sets of flags.",63,null],[11,"bitand_assign","","Disables all flags disabled in the set.",63,null],[11,"sub","","Returns the set difference of the two sets of flags.",63,null],[11,"sub_assign","","Disables all flags enabled in the set.",63,null],[11,"not","","Returns the complement of this set of flags.",63,null],[11,"extend","","",63,null],[11,"from_iter","","",63,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"fmt","","",63,null],[11,"clone","sos_kernel::arch::cpu::control_regs","",53,null],[11,"fmt","","",53,null],[11,"fmt","","",53,null],[11,"eq","sos_kernel::arch::cpu::segment","",64,null],[11,"ne","","",64,null],[11,"clone","","",64,null],[11,"partial_cmp","","",64,null],[11,"lt","","",64,null],[11,"le","","",64,null],[11,"gt","","",64,null],[11,"ge","","",64,null],[11,"cmp","","",64,null],[11,"hash","","",64,null],[11,"fmt","","",64,null],[11,"empty","","Returns an empty set of flags.",64,{"inputs":[],"output":{"name":"selector"}}],[11,"all","","Returns the set containing all flags.",64,{"inputs":[],"output":{"name":"selector"}}],[11,"bits","","Returns the raw value of the flags currently stored.",64,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",64,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",64,{"inputs":[{"name":"u16"}],"output":{"name":"selector"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",64,null],[11,"is_all","","Returns `true` if all flags are currently set.",64,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",64,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",64,null],[11,"insert","","Inserts the specified flags in-place.",64,null],[11,"remove","","Removes the specified flags in-place.",64,null],[11,"toggle","","Toggles the specified flags in-place.",64,null],[11,"bitor","","Returns the union of the two sets of flags.",64,null],[11,"bitor_assign","","Adds the set of flags.",64,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",64,null],[11,"bitxor_assign","","Toggles the set of flags.",64,null],[11,"bitand","","Returns the intersection between the two sets of flags.",64,null],[11,"bitand_assign","","Disables all flags disabled in the set.",64,null],[11,"sub","","Returns the set difference of the two sets of flags.",64,null],[11,"sub_assign","","Disables all flags enabled in the set.",64,null],[11,"not","","Returns the complement of this set of flags.",64,null],[11,"extend","","",64,null],[11,"from_iter","","",64,{"inputs":[{"name":"t"}],"output":{"name":"selector"}}],[11,"new","","Create a new `Selector`",64,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from_raw","","Create a new `Selector` from raw bits",64,{"inputs":[{"name":"u16"}],"output":{"name":"self"}}],[11,"from_cs","","Returns the current value of the code segment register.",64,{"inputs":[],"output":{"name":"self"}}],[11,"index","","Extracts the index from a segment selector",64,null],[11,"set_global","","Sets this segment selector to be a GDT segment.",64,null],[11,"set_local","","Sets this segment selector to be an LDT segment.",64,null],[11,"set_rpl","","Sets the Requested Priveliege Level (RPL)",64,null],[11,"get_rpl","","Checks the segment&#39;s privelige.",64,null],[11,"load_ss","","Load this selector into the stack segment register (`ss`).",64,null],[11,"load_ds","","Load this selector into the data segment register (`ds`).",64,null],[11,"load_es","","Load this selector into the `es` segment register.",64,null],[11,"load_fs","","Load this selector into the `fs` segment register.",64,null],[11,"load_gs","","Load this selector into the `gs` segment register.",64,null],[11,"load_cs","","Load this selector into the code segment register.",64,null],[11,"fmt","","",64,null],[11,"null","","Constructs a new null `Descriptor`",54,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Constructs a new `Descriptor` from a `limit` and a `base` address",54,{"inputs":[{"name":"u32"},{"name":"u32"}],"output":{"name":"self"}}],[11,"get_limit","","Extract the limit part from the flags and limit fields.",54,null],[11,"eq","","",65,null],[11,"ne","","",65,null],[11,"clone","","",65,null],[11,"partial_cmp","","",65,null],[11,"lt","","",65,null],[11,"le","","",65,null],[11,"gt","","",65,null],[11,"ge","","",65,null],[11,"cmp","","",65,null],[11,"hash","","",65,null],[11,"fmt","","",65,null],[11,"empty","","Returns an empty set of flags.",65,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",65,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",65,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",65,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",65,{"inputs":[{"name":"u16"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",65,null],[11,"is_all","","Returns `true` if all flags are currently set.",65,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",65,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",65,null],[11,"insert","","Inserts the specified flags in-place.",65,null],[11,"remove","","Removes the specified flags in-place.",65,null],[11,"toggle","","Toggles the specified flags in-place.",65,null],[11,"bitor","","Returns the union of the two sets of flags.",65,null],[11,"bitor_assign","","Adds the set of flags.",65,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",65,null],[11,"bitxor_assign","","Toggles the set of flags.",65,null],[11,"bitand","","Returns the intersection between the two sets of flags.",65,null],[11,"bitand_assign","","Disables all flags disabled in the set.",65,null],[11,"sub","","Returns the set difference of the two sets of flags.",65,null],[11,"sub_assign","","Disables all flags enabled in the set.",65,null],[11,"not","","Returns the complement of this set of flags.",65,null],[11,"extend","","",65,null],[11,"from_iter","","",65,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"get_dpl","","Get the Descriptor Privilege Level (DPL) from the flags",65,null],[11,"is_system","","Returns true if this segment is a system segment.",65,null],[11,"is_present","","Returns false if this segment is present",65,null],[11,"is_available","","Returns false if this segment is available to system software",65,null],[11,"is_accessed","","Returns true if this is a code or data segment that has been accessed.",65,null],[11,"get_system_type","","Returns the system type indicator, if this is a system segment.",65,null],[11,"get_code_type","","Returns the code type indicator.",65,null],[11,"get_data_type","","Returns the data type indicator.",65,null],[11,"clone","","",55,null],[11,"eq","","",55,null],[11,"ne","","",55,null],[11,"fmt","","",55,null],[11,"clone","","",56,null],[11,"eq","","",56,null],[11,"fmt","","",56,null],[11,"eq","","",66,null],[11,"ne","","",66,null],[11,"clone","","",66,null],[11,"partial_cmp","","",66,null],[11,"lt","","",66,null],[11,"le","","",66,null],[11,"gt","","",66,null],[11,"ge","","",66,null],[11,"cmp","","",66,null],[11,"hash","","",66,null],[11,"fmt","","",66,null],[11,"empty","","Returns an empty set of flags.",66,{"inputs":[],"output":{"name":"dataflags"}}],[11,"all","","Returns the set containing all flags.",66,{"inputs":[],"output":{"name":"dataflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",66,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",66,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",66,{"inputs":[{"name":"u16"}],"output":{"name":"dataflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",66,null],[11,"is_all","","Returns `true` if all flags are currently set.",66,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",66,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",66,null],[11,"insert","","Inserts the specified flags in-place.",66,null],[11,"remove","","Removes the specified flags in-place.",66,null],[11,"toggle","","Toggles the specified flags in-place.",66,null],[11,"bitor","","Returns the union of the two sets of flags.",66,null],[11,"bitor_assign","","Adds the set of flags.",66,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",66,null],[11,"bitxor_assign","","Toggles the set of flags.",66,null],[11,"bitand","","Returns the intersection between the two sets of flags.",66,null],[11,"bitand_assign","","Disables all flags disabled in the set.",66,null],[11,"sub","","Returns the set difference of the two sets of flags.",66,null],[11,"sub_assign","","Disables all flags enabled in the set.",66,null],[11,"not","","Returns the complement of this set of flags.",66,null],[11,"extend","","",66,null],[11,"from_iter","","",66,{"inputs":[{"name":"t"}],"output":{"name":"dataflags"}}],[11,"is_read_only","","Returns true if the data segment is read-only",66,null],[11,"is_accessed","","Returns true if the data segment has been accessed",66,null],[11,"is_expand_down","","Returns true if the data segment expands down",66,null],[11,"eq","","",67,null],[11,"ne","","",67,null],[11,"clone","","",67,null],[11,"partial_cmp","","",67,null],[11,"lt","","",67,null],[11,"le","","",67,null],[11,"gt","","",67,null],[11,"ge","","",67,null],[11,"cmp","","",67,null],[11,"hash","","",67,null],[11,"fmt","","",67,null],[11,"empty","","Returns an empty set of flags.",67,{"inputs":[],"output":{"name":"codeflags"}}],[11,"all","","Returns the set containing all flags.",67,{"inputs":[],"output":{"name":"codeflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",67,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",67,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",67,{"inputs":[{"name":"u16"}],"output":{"name":"codeflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",67,null],[11,"is_all","","Returns `true` if all flags are currently set.",67,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",67,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",67,null],[11,"insert","","Inserts the specified flags in-place.",67,null],[11,"remove","","Removes the specified flags in-place.",67,null],[11,"toggle","","Toggles the specified flags in-place.",67,null],[11,"bitor","","Returns the union of the two sets of flags.",67,null],[11,"bitor_assign","","Adds the set of flags.",67,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",67,null],[11,"bitxor_assign","","Toggles the set of flags.",67,null],[11,"bitand","","Returns the intersection between the two sets of flags.",67,null],[11,"bitand_assign","","Disables all flags disabled in the set.",67,null],[11,"sub","","Returns the set difference of the two sets of flags.",67,null],[11,"sub_assign","","Disables all flags enabled in the set.",67,null],[11,"not","","Returns the complement of this set of flags.",67,null],[11,"extend","","",67,null],[11,"from_iter","","",67,{"inputs":[{"name":"t"}],"output":{"name":"codeflags"}}],[11,"is_exec_only","","Returns true if the code segment is execute-only (not readable)",67,null],[11,"is_readable","","Returns true if the code segment is readable",67,null],[11,"is_accessed","","Returns true if the code segment has been accessed.",67,null],[11,"is_conforming","","Returns true if the code segment is conforming.",67,null],[11,"get_ptr","sos_kernel::arch::cpu::dtable","Get the IDT pointer struct to pass to `lidt` or `lgdt`",58,null],[11,"eq","sos_kernel::arch::cpu::flags","",68,null],[11,"ne","","",68,null],[11,"clone","","",68,null],[11,"partial_cmp","","",68,null],[11,"lt","","",68,null],[11,"le","","",68,null],[11,"gt","","",68,null],[11,"ge","","",68,null],[11,"cmp","","",68,null],[11,"hash","","",68,null],[11,"fmt","","",68,null],[11,"empty","","Returns an empty set of flags.",68,{"inputs":[],"output":{"name":"flags"}}],[11,"all","","Returns the set containing all flags.",68,{"inputs":[],"output":{"name":"flags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",68,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",68,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",68,{"inputs":[{"name":"usize"}],"output":{"name":"flags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",68,null],[11,"is_all","","Returns `true` if all flags are currently set.",68,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",68,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",68,null],[11,"insert","","Inserts the specified flags in-place.",68,null],[11,"remove","","Removes the specified flags in-place.",68,null],[11,"toggle","","Toggles the specified flags in-place.",68,null],[11,"bitor","","Returns the union of the two sets of flags.",68,null],[11,"bitor_assign","","Adds the set of flags.",68,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",68,null],[11,"bitxor_assign","","Toggles the set of flags.",68,null],[11,"bitand","","Returns the intersection between the two sets of flags.",68,null],[11,"bitand_assign","","Disables all flags disabled in the set.",68,null],[11,"sub","","Returns the set difference of the two sets of flags.",68,null],[11,"sub_assign","","Disables all flags enabled in the set.",68,null],[11,"not","","Returns the complement of this set of flags.",68,null],[11,"extend","","",68,null],[11,"from_iter","","",68,{"inputs":[{"name":"t"}],"output":{"name":"flags"}}],[11,"iopl","","",68,null],[11,"clone","sos_kernel::arch::cpu","",45,null],[11,"fmt","","",45,null],[11,"eq","","",45,null],[11,"partial_cmp","","",45,null],[11,"cmp","","",45,null],[11,"current_iopl","","Returns the current I/O Privilege Level from `%eflags`/`%rflags`.",45,{"inputs":[],"output":{"name":"self"}}],[11,"new","","",69,{"inputs":[{"name":"u16"}],"output":{"name":"port"}}],[11,"in8","","Read a byte (8 bits) from this port",69,null],[11,"in16","","Read a word (16 bits) from this port",69,null],[11,"in32","","Read a long word (32 bits) from this port",69,null],[11,"out8","","",69,null],[11,"out16","","",69,null],[11,"out32","","",69,null],[11,"read","","Reads a single byte into the given buffer",69,null],[11,"read_all","","Reads a new byte into each position in the buffer.",69,null],[11,"write","","",69,null],[11,"new_trap","sos_kernel::arch::cpu::interrupts::idt","Returns a new trap gate",70,{"inputs":[],"output":{"name":"self"}}],[11,"new_task","","Returns a new call gate",70,{"inputs":[],"output":{"name":"self"}}],[11,"new_interrupt","","Returns a new interrupt gate",70,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",48,null],[11,"absent","","Creates a new IDT gate marked as `absent`.",48,{"inputs":[],"output":{"name":"self"}}],[11,"from","","Creates a new IDT gate pointing at the given handler function.",48,{"inputs":[{"name":"handler"}],"output":{"name":"self"}}],[11,"from","","Creates a new IDT gate pointing at the given handler function.",48,null],[11,"eq","","",70,null],[11,"ne","","",70,null],[11,"clone","","",70,null],[11,"partial_cmp","","",70,null],[11,"lt","","",70,null],[11,"le","","",70,null],[11,"gt","","",70,null],[11,"ge","","",70,null],[11,"cmp","","",70,null],[11,"hash","","",70,null],[11,"fmt","","",70,null],[11,"empty","","Returns an empty set of flags.",70,{"inputs":[],"output":{"name":"gateflags"}}],[11,"all","","Returns the set containing all flags.",70,{"inputs":[],"output":{"name":"gateflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",70,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",70,{"inputs":[{"name":"u8"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",70,{"inputs":[{"name":"u8"}],"output":{"name":"gateflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",70,null],[11,"is_all","","Returns `true` if all flags are currently set.",70,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",70,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",70,null],[11,"insert","","Inserts the specified flags in-place.",70,null],[11,"remove","","Removes the specified flags in-place.",70,null],[11,"toggle","","Toggles the specified flags in-place.",70,null],[11,"bitor","","Returns the union of the two sets of flags.",70,null],[11,"bitor_assign","","Adds the set of flags.",70,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",70,null],[11,"bitxor_assign","","Toggles the set of flags.",70,null],[11,"bitand","","Returns the intersection between the two sets of flags.",70,null],[11,"bitand_assign","","Disables all flags disabled in the set.",70,null],[11,"sub","","Returns the set difference of the two sets of flags.",70,null],[11,"sub_assign","","Disables all flags enabled in the set.",70,null],[11,"not","","Returns the complement of this set of flags.",70,null],[11,"extend","","",70,null],[11,"from_iter","","",70,{"inputs":[{"name":"t"}],"output":{"name":"gateflags"}}],[11,"is_trap","","",70,null],[11,"is_present","","",70,null],[11,"set_present","","Sets the present bit for this gate",70,null],[11,"get_dpl","","Checks the gate&#39;s privilege",70,null],[11,"set_dpl","","Sets the privilege level of the gate",70,null],[11,"new","","Construct a new IDT with all interrupt gates set to `absent`.",71,{"inputs":[],"output":{"name":"self"}}],[11,"enable_interrupts","","Enable interrupts",71,{"inputs":[],"output":null}],[11,"disable_interrupts","","Disable interrupts",71,{"inputs":[],"output":null}],[11,"add_gate","","Add a new interrupt gate pointing to the given handler",71,null],[11,"add_handlers","","Add interrupt handlers exported by assembly to the IDT.",71,null],[11,"entry_count","","",71,null],[11,"load","","",71,null],[11,"eq","sos_kernel::arch::cpu::interrupts::pics","",49,null],[11,"cmp","","",49,null],[11,"partial_cmp","","",49,null],[11,"clone","","",49,null],[11,"leader","","Construct a new leader PIC",72,{"inputs":[],"output":{"name":"pic"}}],[11,"follower","","Construct a new follower PIC",72,{"inputs":[],"output":{"name":"pic"}}],[11,"is_leader","","Returns true if this PIC is the leader PIC",72,null],[11,"send_data","","Send a byte of data to the PIC",72,null],[11,"initialize","","Send the &quot;initialize&quot; command to this PIC",72,null],[11,"read_isr","","Read the contents of the ISR (Interrupt Service Register) from this PIC",72,null],[11,"read_irr","","Read the contents of the IRR (Interrupt Request Register) from this PIC",72,null],[11,"fmt","sos_kernel::arch::cpu::interrupts","",47,null],[11,"clone","sos_kernel::arch::cpu","",44,null],[11,"to_array","","Transform this struct into an array of `u64`s\n(if you would ever want to do this)",44,null],[11,"empty","","Create a new empty set of Registers",44,{"inputs":[],"output":{"name":"self"}}],[11,"push","","Push the caller-saved registers to the stack\n(such as when handling a context switch or interrupt).",44,{"inputs":[],"output":null}],[11,"pop","","Push the caller-saved registers off the stack\n(such as when handling a context switch or interrupt).",44,{"inputs":[],"output":null}],[11,"fmt","","",44,null],[11,"empty","sos_kernel::arch::cpu::context","",50,{"inputs":[],"output":{"name":"self"}}],[11,"new","sos_kernel::arch::cpu::task","Returns a new, empty TSS",52,{"inputs":[],"output":{"name":"self"}}],[11,"get_ptr","sos_kernel::arch::cpu::dtable","Get the IDT pointer struct to pass to `lidt` or `lgdt`",58,null],[11,"index","sos_kernel::arch::memory::paging::table","",60,null],[11,"index_mut","","",60,null],[11,"zero","","Zeroes out the page table by setting all entries &quot;unused&quot;",60,null],[11,"next_table","","Returns the next table, or `None` if none exists",60,null],[11,"next_table_mut","","Mutably borrows the next table.",60,null],[11,"create_next","","Returns the next table, creating it if it does not exist.",60,null],[11,"eq","","",73,null],[11,"ne","","",73,null],[11,"clone","","",73,null],[11,"partial_cmp","","",73,null],[11,"lt","","",73,null],[11,"le","","",73,null],[11,"gt","","",73,null],[11,"ge","","",73,null],[11,"cmp","","",73,null],[11,"hash","","",73,null],[11,"fmt","","",73,null],[11,"empty","","Returns an empty set of flags.",73,{"inputs":[],"output":{"name":"entryflags"}}],[11,"all","","Returns the set containing all flags.",73,{"inputs":[],"output":{"name":"entryflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",73,null],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",73,{"inputs":[{"name":"u64"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",73,{"inputs":[{"name":"u64"}],"output":{"name":"entryflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",73,null],[11,"is_all","","Returns `true` if all flags are currently set.",73,null],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",73,null],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",73,null],[11,"insert","","Inserts the specified flags in-place.",73,null],[11,"remove","","Removes the specified flags in-place.",73,null],[11,"toggle","","Toggles the specified flags in-place.",73,null],[11,"bitor","","Returns the union of the two sets of flags.",73,null],[11,"bitor_assign","","Adds the set of flags.",73,null],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",73,null],[11,"bitxor_assign","","Toggles the set of flags.",73,null],[11,"bitand","","Returns the intersection between the two sets of flags.",73,null],[11,"bitand_assign","","Disables all flags disabled in the set.",73,null],[11,"sub","","Returns the set difference of the two sets of flags.",73,null],[11,"sub_assign","","Disables all flags enabled in the set.",73,null],[11,"not","","Returns the complement of this set of flags.",73,null],[11,"extend","","",73,null],[11,"from_iter","","",73,{"inputs":[{"name":"t"}],"output":{"name":"entryflags"}}],[11,"is_huge","","Returns true if this page is huge",73,null],[11,"is_present","","Returns true if this page is present",73,null],[11,"do_huge","","",74,null],[11,"is_unused","","Returns true if this is an unused entry",74,null],[11,"set_unused","","Sets this entry to be unused",74,null],[11,"is_huge","","Returns true if this page is huge",74,null],[11,"flags","","Access the entry&#39;s bitflags.",74,null],[11,"get_frame","","Returns the frame in memory pointed to by this page table entry.",74,null],[11,"set","","",74,null],[11,"translate","sos_kernel::arch::memory::paging","",75,null],[11,"translate_page","","",75,null],[11,"map_to","","Modifies the page tables so that `page` maps to `frame`.",75,null],[11,"identity_map","","",75,null],[11,"map_to_any","","",75,null],[11,"new","","",75,{"inputs":[],"output":{"name":"self"}}],[11,"clone","sos_kernel::arch::memory","",59,null],[11,"fmt","","",59,null],[11,"eq","","",59,null],[11,"ne","","",59,null],[11,"partial_cmp","","",59,null],[11,"lt","","",59,null],[11,"le","","",59,null],[11,"gt","","",59,null],[11,"ge","","",59,null],[11,"cmp","","",59,null],[11,"add","","",59,null],[11,"add","","",59,null],[11,"base_addr","","Returns the physical address where this frame starts.",59,null],[11,"containing","","Returns a new frame containing `addr`",59,{"inputs":[{"name":"paddr"}],"output":{"name":"frame"}}],[11,"as_ptr","","Convert the frame into a raw pointer to the frame&#39;s base address",59,null],[11,"as_mut_ptr","","Convert the frame into a raw mutable pointer to the frame&#39;s base address",59,null],[11,"range_between","","Returns a `FrameRange`",59,{"inputs":[{"name":"frame"},{"name":"frame"}],"output":{"name":"framerange"}}],[11,"range_until","","Returns a `FrameRange` on the frames from this frame until the end frame",59,null],[11,"iter","","Returns an iterator over this `FrameRange`",76,null],[11,"next","","",77,null],[11,"get_ptr","sos_kernel::arch::cpu::dtable","Get the IDT pointer struct to pass to `lidt` or `lgdt`",58,null]],"paths":[[8,"Allocator"],[3,"Page"],[8,"FrameAllocator"],[8,"Mapper"],[3,"PageRange"],[3,"PageRangeIter"],[8,"Page"],[3,"VAddr"],[3,"PageRange"],[3,"PageRangeIter"],[3,"Keyboard"],[3,"Scancode"],[3,"Modifiers"],[8,"Read"],[8,"Write"],[4,"Void"],[3,"Info"],[3,"Tag"],[3,"MemMapTag"],[3,"CommandLineTag"],[3,"ModulesTag"],[3,"MemArea"],[3,"ElfSectionsTag"],[4,"TagType"],[4,"MemAreaType"],[3,"MemAreas"],[3,"Binary"],[4,"Header"],[4,"Contents"],[4,"Type"],[8,"AsHeader"],[3,"HeaderRepr"],[3,"Flags"],[3,"GroupFlags"],[3,"Sections"],[3,"Header"],[3,"Ident"],[4,"Class"],[4,"DataEncoding"],[4,"OsAbi"],[4,"Version"],[4,"Type"],[4,"Machine"],[3,"PAddr"],[3,"Registers"],[4,"PrivilegeLevel"],[3,"InterruptContext"],[3,"ExceptionInfo"],[3,"Gate"],[4,"IRQ"],[3,"Context"],[3,"StateDescriptor"],[3,"StateSegment"],[3,"CrState"],[3,"Descriptor"],[4,"Type"],[4,"SysType"],[3,"Pointer"],[8,"DTable"],[3,"Frame"],[3,"Table"],[8,"Sublevel"],[3,"Flags"],[3,"Flags"],[3,"Selector"],[3,"Flags"],[3,"DataFlags"],[3,"CodeFlags"],[3,"Flags"],[3,"Port"],[3,"GateFlags"],[3,"Idt"],[3,"PIC"],[3,"EntryFlags"],[3,"Entry"],[3,"ActivePML4"],[3,"FrameRange"],[3,"FrameRangeIter"]]};
searchIndex["sos_alloc"] = {"doc":"SOS memory allocation library","items":[[0,"buddy","sos_alloc","Simple buddy-block allocator",null,null],[3,"FreeBlock","sos_alloc::buddy","A free block header stores a pointer to the next and previous free blocks.",null,null],[3,"BuddyHeapAllocator","","Structure with data for implementing the buddy block allocation strategy.",null,null],[12,"start_addr","","Address of the base of the heap. This must be aligned\non a `MIN_ALIGN` boundary.",0,null],[12,"heap_size","","Number of blocks in the heap (must be a power of 2)",0,null],[12,"min_block_size","","Minimum block size",0,null],[0,"system","","This module integrates the buddy heap allocator into the Rust runtime.",null,null],[5,"init_heap","sos_alloc::buddy::system","",null,null],[5,"__rust_allocate","","",null,null],[5,"__rust_deallocate","","",null,null],[5,"__rust_reallocate","","",null,null],[5,"__rust_reallocate_inplace","","This is currently unsupported, so we just silently ignore it\nand return the old size.",null,null],[5,"__rust_usable_size","","",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[17,"NUM_FREE_LISTS","","",null,null],[6,"FreeList","sos_alloc::buddy","A `FreeList` is a list of unique free blocks",null,null],[11,"as_ptr","","",1,null],[11,"prev","","",1,null],[11,"next","","",1,null],[11,"prev_mut","","",1,null],[11,"next_mut","","",1,null],[11,"new","","Construct a new `BuddyHeapAllocator`.",0,null],[11,"add_block","","Add a block of max order",0,null],[11,"alloc_size","","Computes the size of an allocation request.",0,null],[11,"alloc_order","","Computes the order of an allocation request.",0,null],[11,"get_buddy","","Finds the buddy block for a given block.",0,null],[11,"remove_block","","Finds and removes the target block from the free list.",0,null],[11,"allocate","","Allocate a new block of size `size` on alignment `align`.",0,null],[11,"deallocate","","Release an allocated block of memory.",0,null],[17,"PAGE_SIZE","sos_alloc","",null,null],[8,"Framesque","","Trait for something that is like a frame.",null,null],[10,"as_ptr","","Return a pointer to the frame in memory.",2,null],[8,"Allocator","","An `Allocator` implements a particular memory allocation strategy.",null,null],[10,"allocate","","Allocate a new block of size `size` on alignment `align`.",3,null],[10,"deallocate","","Release an allocated block of memory.",3,null],[11,"reallocate","","Reallocate `old_frame` from `old_size` bytes to `new_size` bytes",3,null],[11,"zero_alloc","","",3,null]],"paths":[[3,"BuddyHeapAllocator"],[3,"FreeBlock"],[8,"Framesque"],[8,"Allocator"]]};
searchIndex["sos_vga"] = {"doc":"# SOS VGA\nCode for interacting with the system&#39;s VGA buffer.","items":[[3,"Palette","sos_vga","",null,null],[3,"Char","","A colored VGA character.",null,null],[12,"ascii","","",0,null],[12,"colors","","",0,null],[3,"Terminal","","",null,null],[4,"Color","","VGA color codes",null,null],[13,"Black","","",1,null],[13,"Blue","","",1,null],[13,"Green","","",1,null],[13,"Cyan","","",1,null],[13,"Red","","",1,null],[13,"Magenta","","",1,null],[13,"Brown","","",1,null],[13,"LightGrey","","",1,null],[13,"DarkGrey","","",1,null],[13,"LightBlue","","",1,null],[13,"LightGreen","","",1,null],[13,"LightCyan","","",1,null],[13,"LightRed","","",1,null],[13,"LightMagenta","","",1,null],[13,"Yellow","","",1,null],[13,"White","","",1,null],[6,"Buffer","","The type signature fot the actual VGA buffer",null,null],[7,"CONSOLE","","The system&#39;s global VGA terminal",null,null],[17,"X_MAX","","",null,null],[17,"Y_MAX","","",null,null],[11,"eq","","",1,null],[11,"cmp","","",1,null],[11,"partial_cmp","","",1,null],[11,"clone","","",1,null],[11,"eq","","",2,null],[11,"ne","","",2,null],[11,"cmp","","",2,null],[11,"partial_cmp","","",2,null],[11,"lt","","",2,null],[11,"le","","",2,null],[11,"gt","","",2,null],[11,"ge","","",2,null],[11,"clone","","",2,null],[11,"new","","Returns a `Palette` with the given foreground and background color.",2,{"inputs":[{"name":"color"},{"name":"color"}],"output":{"name":"self"}}],[11,"set_foreground","","Returns a new `Palette` with this palette&#39;s background color, and\nthe specified foreground color.",2,null],[11,"set_background","","Returns a new `Palette` with this palette&#39;s foreground color, and\nthe specified background color.",2,null],[11,"foreground","","Returns this `Palette`&#39;s foreground color.",2,null],[11,"background","","Returns this `Palette`&#39;s background color.",2,null],[11,"clone","","",0,null],[11,"new","","Constructs a new `Terminal` for abuffer starting at the given address.",3,{"inputs":[{"name":"palette"},{"name":"usize"}],"output":{"name":"terminal"}}],[11,"set_colors","","Set the color palette used for writing subsequent characters.",3,null],[11,"clear","","Clear the terminal",3,null],[11,"write_byte","","Write the given byte to the terminal, and advance the cursor position.",3,null],[11,"write_str","","",3,null],[14,"println","","Macro for printing to the standard output.",null,null],[14,"print","","Macro for printing to the standard output.",null,null]],"paths":[[3,"Char"],[4,"Color"],[3,"Palette"],[3,"Terminal"]]};
searchIndex["sos_intrusive"] = {"doc":"# SOS Intrusive Collections","items":[[0,"rawlink","sos_intrusive","Implementation of the `RawLink` smart-ish pointer.",null,null],[3,"RawLink","sos_intrusive::rawlink","A `RawLink` provides an `Option`-like interface to a raw pointer.",null,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"ne","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",0,null],[11,"none","","Equivalent of `Option::None` for a `RawLink`",0,{"inputs":[],"output":{"name":"rawlink"}}],[11,"some","","Equivalent of `Option::Some` for a `RawLink`",0,{"inputs":[{"name":"t"}],"output":{"name":"rawlink"}}],[11,"from_raw","","",0,null],[11,"resolve","","Resolve the `RawLink` to an `Option`",0,null],[11,"resolve_mut","","Resolve the `RawLink` to an `Option` on a mutable pointer",0,null],[11,"as_raw","","Please don&#39;t do this.",0,null],[11,"is_some","","",0,null],[11,"is_none","","",0,null],[11,"take","","Returns the `RawLink` and replaces it with `RawLink::none()`.",0,null],[11,"map","","",0,null],[0,"list","sos_intrusive","An intrusive linked list implementation using `RawLink`s.",null,null],[3,"List","sos_intrusive::list","The `List` struct is our way of interacting with an intrusive list.",null,null],[3,"ListCursorMut","","A cursor for an intrusive linked list.",null,null],[8,"OwnedRef","","",null,null],[10,"from_raw","","",1,null],[10,"take","","",1,null],[10,"get","","",1,null],[10,"get_mut","","",1,null],[8,"Node","","This trait defines a node in an intrusive list.",null,null],[10,"next","","",2,null],[10,"prev","","",2,null],[10,"next_mut","","",2,null],[10,"prev_mut","","",2,null],[8,"Cursor","","",null,null],[16,"Item","","",3,null],[10,"next","","",3,null],[10,"prev","","",3,null],[10,"get","","",3,null],[10,"seek_forward","","",3,null],[10,"seek_backward","","",3,null],[11,"new","","Construct a new `List&lt;T, N&gt;` with zero elements",4,{"inputs":[],"output":{"name":"self"}}],[11,"len","","Returns the length of the list",4,null],[11,"front","","Borrows the first element of the list as an `Option`",4,null],[11,"back","","Borrows the last element of the list as an `Option`",4,null],[11,"front_mut","","Mutably borrows the first element of the list as an `Option`",4,null],[11,"back_mut","","Mutably borrows the last element of the list as an `Option`",4,null],[11,"is_empty","","Returns true if the list is empty.",4,null],[11,"push_front","","Push an element to the front of the list.",4,null],[11,"push_back","","Push an element to the back of the list.",4,null],[11,"pop_front","","Removes and returns the element at the front of the list.",4,null],[11,"pop_back","","Removes and returns the element at the end of the list.",4,null],[11,"peek_front","","Borrows the element at the front of the list",4,null],[11,"cursor_mut","","Returns a cursor for iterating over or modifying the list.",4,null],[11,"from_iter","","",4,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"next","","Advances the cursor to the next element and borrows it mutably.",5,null],[11,"prev","","Steps back the cursor to the previous element and borrows it mutably.",5,null],[11,"peek_next","","Borrows the next element in the list without advancing the cursor.",5,null],[11,"peek_prev","","Borrows the previous element without stepping back the cursor.",5,null],[11,"remove","","Removes the element currently under the cursor and returns it.",5,null],[11,"find_and_remove","","Searches for and removes the first element matching a predicate.",5,null],[11,"seek_forward","","Advances the cursor `n` elements and mutably borrows the final element.",5,null],[11,"seek_backward","","Moves the cursor back `n` times and mutably borrows the final element.",5,null]],"paths":[[3,"RawLink"],[8,"OwnedRef"],[8,"Node"],[8,"Cursor"],[3,"List"],[3,"ListCursorMut"]]};
searchIndex["spin"] = {"doc":"Synchronization primitives based on spinning","items":[[3,"Mutex","spin","This type provides MUTual EXclusion based on spinning.",null,null],[3,"MutexGuard","","A guard to which the protected data can be accessed",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","A guard to which the protected data can be read",null,null],[3,"RwLockWriteGuard","","A guard to which the protected data can be written",null,null],[11,"new","","Creates a new spinlock wrapping the supplied data.",0,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"lock","","Locks the spinlock and returns a guard.",0,null],[11,"fmt","","",0,null],[11,"default","","",0,{"inputs":[],"output":{"name":"mutex"}}],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"drop","","The dropping of the MutexGuard will release the lock it was created from.",1,null],[11,"new","","Creates a new spinlock wrapping the supplied data.",2,{"inputs":[{"name":"t"}],"output":{"name":"rwlock"}}],[11,"read","","Locks this rwlock with shared read access, blocking the current thread\nuntil it can be acquired.",2,null],[11,"try_read","","Attempt to acquire this lock with shared read access.",2,null],[11,"write","","Lock this rwlock with exclusive write access, blocking the current\nthread until it can be acquired.",2,null],[11,"try_write","","Attempt to lock this rwlock with exclusive write access.",2,null],[11,"fmt","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"rwlock"}}],[11,"deref","","",3,null],[11,"deref","","",4,null],[11,"deref_mut","","",4,null],[11,"drop","","",3,null],[11,"drop","","",4,null]],"paths":[[3,"Mutex"],[3,"MutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"]]};
searchIndex["bitflags"] = {"doc":"A typesafe bitmask flag generator.","items":[[14,"bitflags","bitflags","The `bitflags!` macro generates a `struct` that holds a set of C-style\nbitmask flags. It is useful for creating typesafe wrappers for C APIs.",null,null]],"paths":[]};
searchIndex["custom_derive"] = {"doc":"This crate provides a macro that enables the use of custom `derive` attributes.","items":[],"paths":[]};
searchIndex["once"] = {"doc":"","items":[[14,"assert_has_not_been_called","once","This macro can be used to ensure that a function is called only once. It panics if the function\nis called a second time.",null,null]],"paths":[]};
searchIndex["rlibc"] = {"doc":"A bare-metal library supplying functions rustc may lower code to","items":[[5,"memcpy","rlibc","",null,null],[5,"memmove","","",null,null],[5,"memset","","",null,null],[5,"memcmp","","",null,null]],"paths":[]};
initSearch(searchIndex);
